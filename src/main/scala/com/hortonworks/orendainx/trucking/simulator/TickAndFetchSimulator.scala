package com.hortonworks.orendainx.trucking.simulator

import akka.actor.{ActorSystem, Inbox}
import com.hortonworks.orendainx.trucking.shared.models.TruckingData
import com.hortonworks.orendainx.trucking.simulator.coordinators.ManualCoordinator
import com.hortonworks.orendainx.trucking.simulator.depots.NoSharingDepot
import com.hortonworks.orendainx.trucking.simulator.flows.SharedFlowManager
import com.hortonworks.orendainx.trucking.simulator.generators.TruckAndTrafficGenerator
import com.hortonworks.orendainx.trucking.simulator.models.{Driver, DrivingPattern}
import com.hortonworks.orendainx.trucking.simulator.transmitters.AccumulateTransmitter
import com.typesafe.config.ConfigFactory

import scala.collection.JavaConversions._
import scala.concurrent.Await
import scala.concurrent.duration._
import scala.util.Random

/**
  * This simulator requires the tick() method to be called to tick the simulator forward.  Generated data can then be
  * retrieved using the fetch() method.
  *
  * This simulator is ideal for use within a custom NiFi processor.
  *
  * @author Edgar Orendain <edgar@orendainx.com>
  * @see https://github.com/orendain/trucking-nifi-bundle for an example of now a custom NiFi processor uses this simulator.
  */
object TickAndFetchSimulator {
  def apply() = new TickAndFetchSimulator()
}

class TickAndFetchSimulator {

  private implicit val config = ConfigFactory.load()
  private val system = ActorSystem("TickAndFetchSimulator")

  // Generate the actors to be used in the simulation and create an Inbox for accepting messages
  private val drivers = generateDrivers()
  private val inbox = Inbox.create(system)

  // Generate the different actors in the simulation
  private val depot = system.actorOf(NoSharingDepot.props())
  private val transmitter = system.actorOf(AccumulateTransmitter.props())
  private val flowManager = system.actorOf(SharedFlowManager.props(transmitter))
  private val dataGenerators = drivers.map { driver => system.actorOf(TruckAndTrafficGenerator.props(driver, depot, flowManager)) }
  private val coordinator = system.actorOf(ManualCoordinator.props(dataGenerators))

  // Ensure that the system is properly terminated when the simulator is shutdown.
  scala.sys.addShutdownHook {
    stop()
  }

  /**
    * Trigger the simulator to tick once.
    */
  def tick(): Unit = {
    coordinator ! ManualCoordinator.Tick
  }

  /**
    * Fetch the data generated since the last call to [[tick()]].
    *
    * As long as this method is not called immediately after a [[tick()]], results should return immediately and
    * the specified timeout is ignored.
    *
    * @param timeout Max amount of time to wait, in milliseconds, for the simulator to respond (default: 1000 milliseconds).
    * @return a list of [[TruckingData]] objects generated by the simulator.
    */
  def fetch(timeout: Int = 1000): List[TruckingData] = {
    inbox.send(transmitter, AccumulateTransmitter.Fetch)
    inbox.receive(timeout.milliseconds).asInstanceOf[List[TruckingData]]
  }

  /**
    * Stop the simulation, terminating the underlying system.
    *
    * @param timeout Time to wait for the system to terminate, in milliseconds (default: 10000 milliseconds).
    */
  def stop(timeout: Int = 10000): Unit = {
    system.terminate()
    Await.result(system.whenTerminated, timeout.milliseconds)
  }

  /**
    * Generate a list of drivers using values from this class's [[com.typesafe.config.Config]] object.
    */
  private def generateDrivers() = {
    // TODO: clean up config abstractions
    // This assumes that special-drivers have sequential ids starting at 1

    // Generate driving patterns
    val patterns = config.getConfigList("simulator.driving-patterns").map { conf =>
      val name = conf.getString("name")
      (name, DrivingPattern(name, conf.getInt("min-speed"), conf.getInt("max-speed"), conf.getInt("risk-frequency")))
    }.toMap

    // First, initialize all special drivers
    val specialDrivers = config.getConfigList("simulator.special-drivers").map { conf =>
      Driver(conf.getInt("id"), conf.getString("name"), patterns(conf.getString("pattern")))
    }

    // If we need more drivers, generate "normal" drivers. Or if we need to remove some special drivers, do so.
    val driverCount = config.getInt("options.driver-count")
    if (specialDrivers.length < driverCount) {
      val newDrivers = ((specialDrivers.length+1) to driverCount).map { newId =>
        val randomDriverName = Random.alphanumeric.take(config.getInt("simulator.driver-name-length")).mkString
        Driver(newId, randomDriverName, patterns("normal"))
      }
      specialDrivers ++ newDrivers
    } else
      specialDrivers.take(driverCount)
  }
}
